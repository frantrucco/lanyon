---
layout: post
title: Introducción a Bash y a otras cositas de Linux/GNU
---
# Proyecto de Programación II

## Objetivos

- La correcta implementación de algoritmos y estructuras de datos avanzados como
  BFS, DFS, Union-Find, conjuntos disjuntos, listas de adyacencias y matrices.

- Aprender a implementar tipos abstractos de datos (TADs), asimilando el
  concepto de ocultamiento de información.

Para ello tendrán que implementar los tipos abstractos de datos adecuados para
resolver al menos dos de los problemas que se dan luego. En cada problema
se especifica como será la entrada de datos y cómo se espera que sea la salida.

En todos los casos el programa será llamado haciendo:

```
python programa.py -i archivo_de_entrada.txt
```

En donde `archivo_de_entrada.txt` será un archivo de texto plano.
Adicionalmente, más entrada podrá ser provista por stdin. Toda salida deberá ser
provista por stdout.


## Laberinto 3D
### Problema

Te encuentras atrapado en un laberinto de 3 dimensiones y debes salir lo más
rápido posible.

El laberinto está compuesto de cubos que pueden ser de piedra o de aire.
Claramente sólo puedes moverte a aquellos cubos que no sean de piedra. Te puedes
mover hacia el Este, el Oeste, el Sur y Norte. Realizar cualquiera de estos
movimientos te lleva 11 segundos. También puedes escalar hacia arriba o
descencer hacia abajo. Escalar te lleva 31 segundos mientras que descender te
lleva 7 segundos.

¿Es posible escapar? ¿Cuánto tiempo te llevará, asumiendo que tomas el camino
más corto? ¿Cuál es ese camino?

### Entrada (archivo)
La primera línea está compuesta por tres números separados por un espacio:
P: número de pisos.
F: número de filas.
C: número de columnas.

Luego, siguen P bloques de F lineas cada una conteniendo C caracteres. Cada
bloque estará separado por dos saltos de línea.

Cada caracter describe una celda del laberinto. Una celda de piedra se indica
con `*`, una celda vacía se indica con `.`, una celda de salida se indica con
`S` y una celda con tu posición inicial se indica con `#`.

#### Ejemplo 1
```
1 3 3
**S
*#*
***
```

#### Ejemplo 2
```
2 5 3
*S*
*.*
*.*
*.*
*#*

.*.
.*.
.*.
.*.
.*.
```

### Entrada (stdin)
No habrá.



### Salida
En caso de que no sea posible escapar se debe escribir "No es posible escapar."
(sin comillas). En caso de que sí sea posible escapar se debe imprimir el tiempo
que se tarda en segundos y el camino más corto entre tu posición inicial y la
salida al laberinto. El camino se imprimirá como una sucesión de movimientos.
Los movimientos posibles son:

- Este
- Oeste
- Sur
- Norte
- Arriba
- Abajo

#### Ejemplo 1
```
No es posible escapar.
```

#### Ejemplo 2
```
44
Norte Norte Norte Norte
```


## Servers (Dijkstra)
Hay N computadoras conectados por cables. Cada uno de los M cables conecta dos
computadoras y tiene cierta latencia medida en microsegundos requerida para
mandar un paquete. Cada computadora tiene una dirección asignada. Una dirección
será representada por un número.

El programa debe responder las pregunta:

- ¿Cuál es el tiempo más corto que se requiere para mandar un mensaje desde una
computadora S a una computadora T a lo largo de la secuencia de cables?

- ¿Por qué computadoras pasa?

### Entrada (archivo)
La primera línea estará compuesta por dos números separados por un espacio:
N: La cantidad de servidores.
M: La cantidad de cables que unen computadoras.

Luego siguen M líneas cada una conteniendo dos direcciones indicando que existe
un cable entre las dos computadoras que tienen esas direcciones y la latencia
medida en microsegundos. Recordar que la existencia de un cable entre dos
computadoras implica que se puede enviar mensajes en cualquiera de los dos
sentidos. Se puede asumir que siempre existe un camino entre dos computadoras.

#### Ejemplo 1
```
3 2
10 20 1000
20 30 1500
```

### Entrada (sdin)
Dos direcciones S y T separadas por un espacio.

#### Ejemplo 1
```
10 30
```

### Salida
Se debe mostrar el tiempo más corto que se requiere para mandar un mensaje desde
una computadora S a una computadora T. Además se debe imprimir la secuencia de
direcciones que sigue ese mensaje.

#### Ejemplo 1
```
2500
10 20 30
```

## Cuerpos de agua

Una imagen satelital en formato raster es una matriz de intensidades. A cada
punto de la matriz se lo denomina píxel. Cada píxel contiene un valor numérico.
¿Pero qué representa este valor numérico? ¿La intensidad de un color? Bueno, eso
depende de la imagen. Algunas imágenes representan el contenido de agua, o el
verdor, u otras cosas. En particular existe un tipo de imágenes satelitales que
nos permiten detectar cuerpos de agua. Este tipo de imágenes se obtiene a través
de un índice llamado NDVI.

El problema es, dada una imagen satelital de este tipo, marcar los cuerpos de
agua. Un cuerpo de agua es un conjunto de píxeles conectados (por ser vecinos)
que tienen un valor menor o igual a -0.2, como puede verse en la fig. 1.

[NDVI](https://upload.wikimedia.org/wikipedia/commons/thumb/9/94/NDVI_062003.png/640px-NDVI_062003.png)
Fig. 1 NVDI promedio en Junio del 2003

### Entrada (archivo)
La primera línea estará compuesta por dos números separados por un espacio:
N: Cantidad de píxeles de ancho de la imagen
M: Cantidad de píxeles de alto de la imagen

Luego siguen N líneas cada una compuesta por M números de punto flotante
separados por un espacio. Estos números se encuentran en el rango [-1, 1] e
indican el NDVI.

#### Ejemplo 1
```
6 3
-0.1 -0.1 -0.1
-0.2 -0.1 -0.2
-0.2 -0.2 -0.2
-0.1 -0.1 -0.1
-0.2 -0.1 -0.2
-0.2 -0.2 -0.2
```

### Entrada (stdin)
No habrá.

### Salida
Se deben imprimir cada uno de los cuerpos de agua. Cada cuerpo de agua se
representa como una lista de coordenadas. Lo que deben hacer es imprimir cada
uno de los cuerpos de agua en una línea separando cada par de coordenadas por un
espacio y cada coordenada por una coma. Recuerden que las imágenes empiezan en
la esquina superior izquierda.

#### Ejemplo 1
```
1,0 1,2 2,0 2,1 2,2
4,0 4,2 5,0 5,1 5,2
```
